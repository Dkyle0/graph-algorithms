// floydWarshall.js

/*
Алгоритм Флойда-Уоршелла

Алгоритм Флойда-Уоршелла вычисляет кратчайшие пути между всеми парами вершин в графе.
Это пример динамического программирования и работает с графами с положительными или
отрицательными весами ребер.

Он использует матрицу dist, где dist[i][j] представляет собой кратчайший путь от вершины i к вершине j.

Плюсы:

Находит кратчайшие пути между всеми парами вершин.
Эффективен для небольших и средних графов из-за кубической сложности времени выполнения.
Работает с графами с отрицательными весами, если нет циклов отрицательного веса.
Минусы:

Неэффективен для больших графов из-за высокой вычислительной сложности O(V^3).
Требует O(V^2) памяти для хранения матрицы dist.
Не подходит для динамически изменяющихся графов, так как требует полного пересчета после каждого изменения.
*/

function floydWarshall(graph) {
    let dist = {};
    let vertices = Object.keys(graph);

    vertices.forEach(v => {
        dist[v] = {};
        vertices.forEach(u => {
            if (v === u) {
                dist[v][u] = 0;
            } else if (graph[v][u]) {
                dist[v][u] = graph[v][u];
            } else {
                dist[v][u] = Infinity;
            }
        });
    });

    vertices.forEach(k => {
        vertices.forEach(i => {
            vertices.forEach(j => {
                dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
            });
        });
    });

    return dist;
}

let graph = {
    'A': { 'B': 1, 'C': 4 },
    'B': { 'A': 1, 'D': 2, 'E': 5 },
    'C': { 'A': 4, 'F': 3 },
    'D': { 'B': 2, 'E': -3 },
    'E': { 'B': 5, 'F': 1 },
    'F': { 'C': 3, 'E': 1 }
};

console.log(floydWarshall(graph));

module.exports = floydWarshall;